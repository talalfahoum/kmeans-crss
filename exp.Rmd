---
title: "An exploration of Cross-Stiching with Clustering"
author: "Talal Fahoum"
date: "01/11/2020"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
source("exp_funcs.R")
```
## Cross-stich Overview
To provide a brief overview of the following investigation: we wish to understand how clustering, particular k-means clustering can apply to images. More specifically, we want to visualize a way of creating a cross-stich pattern of an image of our choosing. Below, the investigation should leave the reader with a good understanding of how we can use k-means clustering to achieve this exact pattern.

## Function 1 - Processing & Cluster information
First of all, we want to ask ourselves: how can we generate some valuable information about our image based on different cluster sizes. This is exactly what our first function, 'process_image' answers, as it compiles various valuable data about a k-means clustering for each cluster size we would like to investigate. As an example we could choose to investigate how clustering information differs across cluster sizes of 1 through 6. Instead, for now, and mainly for the purposes of simplicity we will choose to focus on one cluster size for the remainder of the report: 6. Below we take a quick look about this so called 'table of tables' we call 'cluster_info'. If we wanted to focus on a variety of cluster sizes, we could have passed in a list of cluster sizes and our 'cluster_info' variable would harbor tables of information about each cluster size. 

Some of the important pieces of information included in this table comprise things such as: Hex code associated with cluster centres, data we can use to plot a scree plot with, and original output of the kmeans cluster process - these are just a few examples. 
```{r, echo=TRUE, warning=FALSE, message=FALSE}
file_name = "image_will.png"
k_l = c(6)
cluster_info = process_image(file_name, k_l)
cluster_info
```


## Function 2 - Producing our Scree Plot
If we were to examine which cluster size would be most effective for tackling this problem in an apt manner - a scree plot may be a good option to do exactly so. We could have plotted a scree plot for the initial pool of cluster sizes we wanted to explor - which only comprised of 6 - but this would have only resulted in one point on our graph. Instead, when examining a wide pool of cluster sizes in a scree plot - such 1 through 6 - we receive a more revealing sign of which cluster size we should choose. Below, the output of our scree plot suggests that an apt choice for a cluster size would be about 6, a value at which how much variation is accounted for by each particular cluster begins to reach a point of diminishing returns. This - in a very observational manner - signals to us that our initial choice of 6 as the cluster size we wanted to proceed with, was not necessarily a bad one. To properly use this function, we would simply need to pass a 'cluster_info' tibble generated by our initial function; the function relies heavily on the 'glanced' column of our initial tibble.
```{r, echo=TRUE, warning=FALSE, message=FALSE}
k_big_list = c(1:6)
var_cluster_info = process_image(file_name, k_big_list)
scree_plot(var_cluster_info)
```


## Function 3 - Generating our color strips
Moving on, in this section we wanted to explore the exact colors that are similar to the colors of our cluster center - per clustering done in our initial function. For example if we were to choose our 'k_l' in our first function to be a list of numbers 1 through 6, we would consequently get 6 color strips, with each color strip representing an approximation of the cluster center color for each experiment we carried out - from 1 through 6. These approximations are based on the DMC package we used, where we end up deciphering the hex-code of the DMC color that is closest to the color of our cluster center. Below, we are able to demonstrate the resultant output for carrying out 1 clustering experiment for a cluster size of 6, as indicated in our first section. To use this function properly, one would simply need to pass in a tibble of 'cluster_info' generated by our first 'processing_image' function
```{r, echo=TRUE, warning=FALSE, message=FALSE}
color_strips(cluster_info)
```


## Function 4 - Finally, let's make the pattern!
Finally, we can now begin to visualize some material progress. Before we go onto generating our coveted cross-stitch pattern, we simply want to check if we are on the right track, by plotting our image using its coordinates separated and designated to a certain cluster from our 6 choices - 1 through 6. In order to do this, we first need to convert the columns from our initial cluster information tibble into a usable form, since they are not usable in their current list form. After converting the relevant 'augmented' and 'tidied' and 'dmc' columns, we can proceed accordingly. Based on our output, we can see that we are indeed on the correct track and have managed to successfully regenerate our image from our tabulated information about each cluster. We also have a legend and key associated with the output below to indicated which color came from which exact cluster number out of the 6.
```{r, echo=TRUE, warning=FALSE, message=FALSE}
clustering_example <- cluster_info %>%
      unnest(cols = c(tidied))
augment_example <- cluster_info %>%
    unnest(cols = c(augmented))
ggplot(augment_example, aes(x=x, y = y, fill = .cluster)) + geom_tile() +
  scale_discrete_manual(aesthetics = "fill", values = clustering_example$col) + 
  scale_y_reverse() + theme_void()

```

We have now reached our last and most important step: creating the cross-stitch pattern. Since our 'make_pattern' function visualizes our pattern based on the entered parameters, we wanted to examine what these differences entail. In our first generated pattern, we wanted to visualize said pattern only in black and white, hence the absence of any color. In spite of this, we still included the key and legend that provide us with insight on which cluster is filling which area of space - this is indicated by their according shape. 

```{r, echo=TRUE, warning=FALSE, message=FALSE}
make_pattern(cluster_info, 6, 55, black_white=TRUE)
```

Next, we wanted to visualize the exact same pattern but with color this time. The colors included comprise the colors included in the output of our third function, 'color_strips', and the key and legend serves the exact same aforementioned purpose. Note, that here we include the names of the colors rather than their hex-code as demonstrated in 'color_strips'.

```{r, echo=TRUE, warning=FALSE, message=FALSE}
make_pattern(cluster_info, 6, 55)
```
Finally, our last two plots reveal some important information about the functionality of our last 'make_pattern' function - namely that it assumes, by default that the picture or image we wish to investigate has no background color. In the previous output, we passed in the image but we did not comply with the function's restrictions since the image at hand clearly has a background color. We did this to merely demonstrate the totality of the cross-stitch pattern before accounting for background color. But, to comply with the function signature, we must include the background color of our image, indicated below by '#FFCB05', in order for our function to remove it in the resulting cross-stitch pattern. This applies accordingly for our black and white pattern as well as show in our final plot
```{r, echo=TRUE, warning=FALSE, message=FALSE}
make_pattern(cluster_info, 6, 55, background_color = '#FFCB05')
make_pattern(cluster_info, 6, 55, black_white = TRUE, background_color = '#FFCB05')
```

## Closing remarks
To conclude, we have successfully demonstrated how to generate a cross-stitch pattern for an image of one's choosing by using the straight-forward principles and rules of k-means analysis. Mainly, we have learned that our outcome truly depends on the cluster size we choose to examine, and that we need to ensure that we have proceeded with the correct one in order to maximize the quality of our analysis. This essentially means that we have to try different things in order to increase the likelihood of whether or not we are right. In the meantime, I will certainly be exploring this algorithm with tons of different images!




